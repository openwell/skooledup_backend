{"version":3,"sources":["../../src/utils/helpers.js"],"names":["auth","password","bcrypt","hashSync","genSaltSync","hashPassword","compareSync","id","isAdmin","token","jwt","sign","userId","process","env","JWT_SECRET","expiresIn","req","res","next"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;IAEMA,I;;;;;;;WACJ,sBAAoBC,QAApB,EAA8B;AAC5B,aAAOC,qBAAOC,QAAP,CAAgBF,QAAhB,EAA0BC,qBAAOE,WAAP,CAAmB,CAAnB,CAA1B,CAAP;AACD;;;WAED,yBAAuBC,YAAvB,EAAqCJ,QAArC,EAA+C;AAC7C,aAAOC,qBAAOI,WAAP,CAAmBL,QAAnB,EAA6BI,YAA7B,CAAP;AACD;;;WAED,uBAAqBE,EAArB,EAAyBC,OAAzB,EAAkC;AAChC,UAAMC,KAAK,GAAGC,yBAAIC,IAAJ,CACZ;AACEC,QAAAA,MAAM,EAAEL,EADV;AAEEC,QAAAA,OAAO,EAAEA;AAFX,OADY,EAKZK,OAAO,CAACC,GAAR,CAAYC,UALA,EAMZ;AAAEC,QAAAA,SAAS,EAAE;AAAb,OANY,CAAd;;AAQA,aAAOP,KAAP;AACD;;;;iFAED,iBAAyBQ,GAAzB,EAA8BC,GAA9B,EAAmCC,IAAnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iDAiBWA,IAAI,EAjBf;;AAAA;AAAA;AAAA;AAAA,iDAmBW,8BAAa,GAAb,EAAkBD,GAAlB,cAnBX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;QAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;eAGalB,I","sourcesContent":["import bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport model from '../model/auth';\nimport errorHandler from '../middleware/errorHandler';\n\nclass auth {\n  static hashPassword(password) {\n    return bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n  }\n\n  static comparePassword(hashPassword, password) {\n    return bcrypt.compareSync(password, hashPassword);\n  }\n\n  static generateToken(id, isAdmin) {\n    const token = jwt.sign(\n      {\n        userId: id,\n        isAdmin: isAdmin,\n      },\n      process.env.JWT_SECRET,\n      { expiresIn: '1d' }\n    );\n    return token;\n  }\n\n  static async verifyToken(req, res, next) {\n    // const token = req.headers.authorization;\n    // if (!token) {\n    //   return errorHandler(401, res, 'Token is not provided');\n    // }\n    // const tokenArray = token.split(' ');\n    // try {\n    //   const decoded = await jwt.verify(tokenArray[1], process.env.JWT_SECRET);\n    //   if (decoded.isAdmin === 'true') {\n    //     return errorHandler(403, res, 'Token Forbidden');\n    //   }\n    //   const row = await model.getUserById(decoded.userId);\n    //   if (!row) {\n    //     return errorHandler(401, res, 'Invalid token');\n    //   }\n    //   req.user = { id: decoded.userId, isAdmin: decoded.isAdmin };\n    try {\n      return next();\n    } catch (error) {\n      return errorHandler(401, res, error);\n    }\n  }\n\n  // static async adminVerifyToken(req, res, next) {\n  //   const token = req.headers.tokens;\n  //   if (!token) {\n  //     return errorHandler(401, res, 'Token is not provided');\n  //   }\n  //   try {\n  //     const decoded = await jwt.verify(token, process.env.SECRET);\n  //     if (decoded.isAdmin === 'false') {\n  //       return errorHandler(403, res, 'Token Forbidden');\n  //     }\n  //     const { rows } = await db.query(queries.selectById('admins', 'id', decoded.userId));\n  //     if (!rows[0]) {\n  //       return errorHandler(401, res, 'Invalid token');\n  //     }\n  //     req.user = { id: decoded.userId, isadmin: decoded.isAdmin };\n  //     return next();\n  //   } catch (error) {\n  //     return errorHandler(401, res, error);\n  //   }\n  // }\n}\n\nexport default auth;\n"],"file":"helpers.js"}